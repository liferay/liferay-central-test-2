{"version":3,"sources":["/source/IncrementalDomRenderer.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { array, core, object } from 'metal';\nimport dom from 'metal-dom';\nimport { ComponentRenderer, EventsCollector } from 'metal-component';\nimport IncrementalDomAop from './IncrementalDomAop';\n\n/**\n * Class responsible for rendering components via incremental dom.\n */\nclass IncrementalDomRenderer extends ComponentRenderer {\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(comp) {\n\t\tsuper(comp);\n\n\t\tthis.changes_ = {};\n\t\tthis.eventsCollector_ = new EventsCollector(comp);\n\t\tcomp.on('stateKeyChanged', this.handleStateKeyChanged_.bind(this));\n\t\tcomp.on('detached', this.handleDetached_.bind(this));\n\t}\n\n\t/**\n\t * Adds all inline listener attributes included in the given config.\n\t * @param {!Array} listeners\n\t * @protected\n\t */\n\taddInlineListeners_(listeners) {\n\t\tfor (var i = 0; i < listeners.length; i += 2) {\n\t\t\tvar name = listeners[i];\n\t\t\tvar fn = listeners[i + 1];\n\t\t\tif (name.startsWith('data-on') && core.isString(fn)) {\n\t\t\t\tthis.listenersToAttach_.push({\n\t\t\t\t\teventName: name.substr(7),\n\t\t\t\t\tfn\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Attaches any inline listeners found in the contents built via the last\n\t * incremental dom patch.\n\t * @protected\n\t */\n\tattachInlineListeners_() {\n\t\tthis.eventsCollector_.startCollecting();\n\t\tfor (var i = 0; i < this.listenersToAttach_.length; i++) {\n\t\t\tvar listener = this.listenersToAttach_[i];\n\t\t\tthis.eventsCollector_.attachListener(listener.eventName, listener.fn);\n\t\t}\n\t}\n\n\t/**\n\t * Disposes all sub components that were not found after an update anymore.\n\t * @protected\n\t */\n\tdisposeUnusedSubComponents_() {\n\t\tvar keys = Object.keys(this.component_.components);\n\t\tvar unused = [];\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (!this.subComponentsFound_[keys[i]]) {\n\t\t\t\tunused.push(keys[i]);\n\t\t\t}\n\t\t}\n\t\tthis.component_.disposeSubComponents(unused);\n\t}\n\n\t/**\n\t * Gets the current rendering data for this component.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tgetRenderingData() {\n\t\tif (!this.renderingData_) {\n\t\t\tthis.renderingData_ = object.mixin({}, this.component_.getInitialConfig());\n\t\t}\n\t\treturn this.renderingData_;\n\t}\n\n\t/**\n\t * Gets the sub component referenced by the given tag and config data,\n\t * creating it if it doesn't yet exist.\n\t * @param {string} key The sub component's key.\n\t * @param {string|!Function} tagOrCtor The tag name.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The sub component.\n\t * @protected\n\t */\n\tgetSubComponent_(key, tagOrCtor, config) {\n\t\tvar comp = this.component_.addSubComponent(key, tagOrCtor, config);\n\t\tif (comp.wasRendered) {\n\t\t\tcomp.setState(config);\n\t\t}\n\t\tcomp.componentIncrementalDomKey_ = key;\n\t\treturn comp;\n\t}\n\n\t/**\n\t * Guarantees that the component's element has a parent. That's necessary\n\t * when calling incremental dom's `patchOuter` for now, as otherwise it will\n\t * throw an error if the element needs to be replaced.\n\t * @return {Element} The parent, in case it was added.\n\t * @protected\n\t */\n\tguaranteeParent_() {\n\t\tvar element = this.component_.element;\n\t\tif (!element || !element.parentNode) {\n\t\t\tvar parent = document.createElement('div');\n\t\t\tif (element) {\n\t\t\t\tdom.append(parent, element);\n\t\t\t}\n\t\t\treturn parent;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the `detached` listener. Removes all inline listeners.\n\t * @protected\n\t */\n\thandleDetached_() {\n\t\tthis.eventsCollector_.detachAllListeners();\n\t}\n\n\t/**\n\t * Handles an intercepted call to the attributes default handler from\n\t * incremental dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {!Element} element\n\t * @param {string} name\n\t * @param {*} value\n\t * @protected\n\t */\n\thandleInterceptedAttributesCall_(originalFn, element, name, value) {\n\t\tif (name.startsWith('data-on')) {\n\t\t\tvar eventName = name.substr(7);\n\t\t\tif (core.isFunction(element[name])) {\n\t\t\t\telement.removeEventListener(eventName, element[name]);\n\t\t\t}\n\t\t\tif (core.isFunction(value)) {\n\t\t\t\tdom.on(element, eventName, value);\n\t\t\t}\n\t\t} else if (name === 'checked') {\n\t\t\t// This is a temporary fix to account for incremental dom setting\n\t\t\t// \"checked\" as an attribute only, which can cause bugs since that won't\n\t\t\t// necessarily check/uncheck the element it's set on. See\n\t\t\t// https://github.com/google/incremental-dom/issues/198 for more details.\n\t\t\telement.checked = core.isDefAndNotNull(value) && value !== false;\n\t\t}\n\t\toriginalFn(element, name, value);\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementClose` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedCloseCall_(originalFn, tag) {\n\t\tif (!this.isComponentTag_(tag)) {\n\t\t\toriginalFn(tag);\n\t\t}\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @protected\n\t */\n\thandleInterceptedOpenCall_(originalFn, tag) {\n\t\tvar node;\n\t\tif (this.isComponentTag_(tag)) {\n\t\t\tnode = this.handleSubComponentCall_.apply(this, arguments);\n\t\t} else {\n\t\t\tnode = this.handleRegularCall_.apply(this, arguments);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a regular element. Adds any inline listeners found and makes\n\t * sure that component root elements are always reused.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @param {?string} key\n\t * @param {?Array} statics\n\t * @protected\n\t */\n\thandleRegularCall_(originalFn, tag, key, statics) {\n\t\tvar attrsArr = array.slice(arguments, 4);\n\t\tthis.addInlineListeners_((statics || []).concat(attrsArr));\n\t\tvar args = array.slice(arguments, 1);\n\t\tif (!this.rootElementReached_ && this.component_.componentIncrementalDomKey_) {\n\t\t\targs[1] = this.component_.componentIncrementalDomKey_;\n\t\t}\n\t\tvar node = originalFn.apply(null, args);\n\t\tif (!this.rootElementReached_) {\n\t\t\tthis.rootElementReached_ = true;\n\t\t\tif (this.component_.element !== node) {\n\t\t\t\tthis.component_.element = node;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Handles the `stateKeyChanged` event. Makes sure that, when `stateChanged`\n\t * is fired, the component's contents will only be updated if the changed\n\t * state key wasn't `element`, since that wouldn't cause a rerender.\n\t * @param {!Object} data\n\t * @protected\n\t */\n\thandleStateKeyChanged_(data) {\n\t\tif (data.key !== 'element') {\n\t\t\tthis.changes_[data.key] = data;\n\t\t}\n\t}\n\n\t/**\n\t * Handles an intercepted call to the `elementOpen` function from incremental\n\t * dom, done for a sub component element. Creates and updates the appropriate\n\t * sub component.\n\t * @param {!function()} originalFn The original function before interception.\n\t * @param {string} tag\n\t * @param {?string} key\n\t * @param {?Array} statics\n\t * @protected\n\t */\n\thandleSubComponentCall_(originalFn, tag, key, statics) {\n\t\tvar config = {};\n\t\tvar attrsArr = (statics || []).concat(array.slice(arguments, 4));\n\t\tfor (var i = 0; i < attrsArr.length; i += 2) {\n\t\t\tconfig[attrsArr[i]] = attrsArr[i + 1];\n\t\t}\n\n\t\tvar tagOrCtor = tag;\n\t\tif (tag === 'Component' && config.ctor) {\n\t\t\ttagOrCtor = config.ctor;\n\t\t\tconfig = config.data || {};\n\t\t}\n\t\tvar comp = this.renderSubComponent_(tagOrCtor, config);\n\t\treturn comp.element;\n\t}\n\n\t/**\n\t * Checks if the given tag represents a metal component.\n\t * @param {string} tag\n\t * @protected\n\t */\n\tisComponentTag_(tag) {\n\t\treturn tag[0] === tag[0].toUpperCase();\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`.\n\t */\n\trender() {\n\t\tthis.patch();\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t * @param {!Object} data Data passed to the component when rendering it.\n\t */\n\trenderIncDom() {\n\t\tIncrementalDOM.elementVoid('div');\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, but\n\t * doesn't call `patch` yet. Rather, this will be the function that should be\n\t * called by `patch`.\n\t * @param {Object=} opt_data Data passed to the component when rendering it.\n\t */\n\trenderWithoutPatch(opt_data) {\n\t\t// Mark that there shouldn't be an update for state changes so far, since\n\t\t// render has already been called.\n\t\tthis.changes_ = {};\n\n\t\tthis.rootElementReached_ = false;\n\t\tthis.subComponentsFound_ = {};\n\t\tthis.generatedKeyCount_ = 0;\n\t\tthis.listenersToAttach_ = [];\n\t\tIncrementalDomAop.startInterception(\n\t\t\tthis.handleInterceptedOpenCall_.bind(this),\n\t\t\tthis.handleInterceptedCloseCall_.bind(this),\n\t\t\tthis.handleInterceptedAttributesCall_.bind(this)\n\t\t);\n\t\tobject.mixin(this.getRenderingData(), opt_data);\n\t\tthis.renderIncDom(this.getRenderingData());\n\t\tIncrementalDomAop.stopInterception();\n\t\tthis.attachInlineListeners_();\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * Can be overridden by subclasses to provide customized behavior (only\n\t * updating when a state key used by the template is changed for example).\n\t * @param {!Object} changes\n\t * @return {boolean}\n\t */\n\tshouldUpdate() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Patches the component's element with the incremental dom function calls\n\t * done by `renderIncDom`.\n\t */\n\tpatch() {\n\t\tvar tempParent = this.guaranteeParent_();\n\t\tif (tempParent) {\n\t\t\tIncrementalDOM.patch(tempParent, this.renderWithoutPatch.bind(this));\n\t\t\tdom.exitDocument(this.component_.element);\n\t\t} else {\n\t\t\tIncrementalDOM.patchOuter(this.component_.element, this.renderWithoutPatch.bind(this));\n\t\t}\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through the incremental dom function calls done by `renderIncDom`.\n\t */\n\tupdate() {\n\t\tvar changedKeys = Object.keys(this.changes_);\n\t\tif (changedKeys.length > 0 && this.shouldUpdate(this.changes_)) {\n\t\t\tthis.patch();\n\t\t\tthis.eventsCollector_.detachUnusedListeners();\n\t\t\tthis.disposeUnusedSubComponents_();\n\t\t}\n\t}\n\n\t/**\n\t * This updates the sub component that is represented by the given data.\n\t * The sub component is created, added to its parent and rendered. If it\n\t * had already been rendered before though, it will only have its state\n\t * updated instead.\n\t * @param {string|!function()} tagOrCtor The tag name or constructor function.\n\t * @param {!Object} config The config object for the sub component.\n\t * @return {!Component} The updated sub component.\n\t * @protected\n\t */\n\trenderSubComponent_(tagOrCtor, config) {\n\t\tvar key = config.key || ('sub' + this.generatedKeyCount_++);\n\t\tvar comp = this.getSubComponent_(key, tagOrCtor, config);\n\t\tvar renderer = comp.getRenderer();\n\t\tif (renderer instanceof IncrementalDomRenderer) {\n\t\t\trenderer.renderWithoutPatch(config);\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'IncrementalDomRenderer doesn\\'t support rendering sub components ' +\n\t\t\t\t'that don\\'t use IncrementalDomRenderer as well, like:',\n\t\t\t\tcomp\n\t\t\t);\n\t\t}\n\t\tif (!comp.wasRendered) {\n\t\t\tcomp.renderAsSubComponent();\n\t\t}\n\t\tthis.subComponentsFound_[key] = true;\n\t\treturn comp;\n\t}\n}\n\nexport default IncrementalDomRenderer;\n"]}