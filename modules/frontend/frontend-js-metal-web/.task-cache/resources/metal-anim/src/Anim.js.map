{"version":3,"sources":["/source/Anim.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;KAKM;;;;;OASE,iCAAW,SAAS,gBAAgB;AAC1C,OAAI,KAAK,qBAAL,CAA2B,OAA3B,EAAoC,WAApC,IAAmD,KAAK,qBAAL,CAA2B,OAA3B,EAAoC,YAApC,CAAnD,EAAsG;AACzG,WAAO,KAAK,WAAL,CAAiB,OAAjB,EAA0B,WAA1B,EAAuC,cAAvC,CAAP,CADyG;IAA1G,MAEO;AACN,WAAO,KAAK,WAAL,CAAiB,OAAjB,EAA0B,YAA1B,EAAwC,cAAxC,CAAP,CADM;IAFP;;;AAVI,OAwBE,mDAAoB,SAAS,gBAAgB;AACnD,UAAO,KAAK,WAAL,CAAiB,OAAjB,EAA0B,WAA1B,EAAuC,cAAvC,CAAP,CADmD;;;AAxB/C,OAmCE,qDAAqB,SAAS,gBAAgB;AACpD,QAAK,WAAL,CAAiB,OAAjB,EAA0B,YAA1B,EAAwC,cAAxC,EADoD;;;AAnChD,OA+CE,mCAAY,SAAS,MAAM,gBAAgB;AACjD,OAAI,WAAW,cAAX,CAD6C;AAEjD,OAAI,CAAC,gBAAK,KAAL,CAAW,cAAX,CAAD,EAA6B;AAChC,eAAW,KAAK,qBAAL,CAA2B,OAA3B,EAAoC,IAApC,CAAX,CADgC;IAAjC;;AAIA,OAAI,UAAU,WAAW,YAAW;AACnC,aAAI,YAAJ,CAAiB,OAAjB,EAA0B,cAAS,uBAAT,GAAmC,IAAnC,CAA1B,EADmC;IAAX,EAEtB,QAFW,CAAV,CAN6C;;AAUjD,OAAI,QAAQ,SAAR,KAAQ,GAAW;AACtB,iBAAa,OAAb,EADsB;AAEtB,sBAAkB,cAAlB,GAFsB;IAAX,CAVqC;AAcjD,OAAI,oBAAoB,SAAI,IAAJ,CAAS,OAAT,EAAkB,OAAO,KAAP,EAAc,KAAhC,CAApB,CAd6C;;AAgBjD,UAAO;AACN,WAAO,KAAP;IADD,CAhBiD;;;AA/C7C,OA0EE,uDAAsB,SAAS,MAAM;AAC3C,UAAO,CAAC,WAAW,OAAO,gBAAP,CAAwB,OAAxB,EAAiC,IAAjC,EAAuC,gBAAvC,CAAwD,OAAO,WAAP,CAAnE,KAA2F,CAA3F,CAAD,GAAiG,IAAjG,CADoC;;;SA1EvC;;;mBA+ES","sourcesContent":["'use strict';\n\nimport core from 'metal';\nimport { dom, features } from 'metal-dom';\n\nclass Anim {\n\t/**\n\t * Emulates animation or transition end event, the end event with longer\n\t * duration will be used by the emulation. If they have the same value,\n\t * transitionend will be emulated.\n\t * @param {!Element} element\n\t * @param {number=} opt_durationMs\n\t * @return {!Object} Object containing `abort` function.\n\t */\n\tstatic emulateEnd(element, opt_durationMs) {\n\t\tif (this.getComputedDurationMs(element, 'animation') > this.getComputedDurationMs(element, 'transition')) {\n\t\t\treturn this.emulateEnd_(element, 'animation', opt_durationMs);\n\t\t} else {\n\t\t\treturn this.emulateEnd_(element, 'transition', opt_durationMs);\n\t\t}\n\t}\n\n\t/**\n\t * Emulates animation end event. If `opt_durationMs` not specified the value\n\t * will read from computed style for animation-duration.\n\t * @param {!Element} element\n\t * @param {number=} opt_durationMs\n\t * @return {!Object} Object containing `abort` function.\n\t */\n\tstatic emulateAnimationEnd(element, opt_durationMs) {\n\t\treturn this.emulateEnd_(element, 'animation', opt_durationMs);\n\t}\n\n\t/**\n\t * Emulates transition end event. If `opt_durationMs` not specified the\n\t * value will read from computed style for transition-duration.\n\t * @param {!Element} element\n\t * @param {number=} opt_durationMs\n\t * @return {!Object} Object containing `abort` function.\n\t */\n\tstatic emulateTransitionEnd(element, opt_durationMs) {\n\t\tthis.emulateEnd_(element, 'transition', opt_durationMs);\n\t}\n\n\t/**\n\t * Emulates transition or animation end.\n\t * @param {!Element} element\n\t * @param {string} type\n\t * @param {number=} opt_durationMs\n\t * @return {!Object} Object containing `abort` function.\n\t * @protected\n\t */\n\tstatic emulateEnd_(element, type, opt_durationMs) {\n\t\tvar duration = opt_durationMs;\n\t\tif (!core.isDef(opt_durationMs)) {\n\t\t\tduration = this.getComputedDurationMs(element, type);\n\t\t}\n\n\t\tvar delayed = setTimeout(function() {\n\t\t\tdom.triggerEvent(element, features.checkAnimationEventName()[type]);\n\t\t}, duration);\n\n\t\tvar abort = function() {\n\t\t\tclearTimeout(delayed);\n\t\t\thoistedEvtHandler.removeListener();\n\t\t};\n\t\tvar hoistedEvtHandler = dom.once(element, type + 'end', abort);\n\n\t\treturn {\n\t\t\tabort: abort\n\t\t};\n\t}\n\n\t/**\n\t * Gets computed style duration for duration.\n\t * @param {!Element} element\n\t * @param {string} type\n\t * @return {number} The computed duration in milliseconds.\n\t */\n\tstatic getComputedDurationMs(element, type) {\n\t\treturn (parseFloat(window.getComputedStyle(element, null).getPropertyValue(type + '-duration')) || 0) * 1000;\n\t}\n}\n\nexport default Anim;\n"]}