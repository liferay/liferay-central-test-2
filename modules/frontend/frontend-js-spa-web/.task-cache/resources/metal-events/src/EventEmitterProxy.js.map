{"version":3,"sources":["/source/EventEmitterProxy.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAkBM;;;AACL,WADK,iBACL,CAAY,aAAZ,EAA2B,aAA3B,EAA0C,aAA1C,EAAyD,aAAzD,EAAwE;yBADnE,mBACmE;;gDACvE,wBADuE;;;;;;;AAQvE,SAAK,UAAL,GAAkB,iBAAiB,EAAjB;;;;;;;;AARqD,QAgBvE,CAAK,cAAL,GAAsB,aAAtB;;;;;;;AAhBuE,QAuBvE,CAAK,cAAL,GAAsB,EAAtB;;;;;;;;AAvBuE,QA+BvE,CAAK,cAAL,GAAsB,aAAtB;;;;;;;AA/BuE,QAsCvE,CAAK,UAAL,GAAkB,aAAlB,CAtCuE;;AAwCvE,SAAK,WAAL,GAxCuE;;GAAxE;;;;;;;;;AADK,8BAiDL,qCAAa,OAAO;AACnB,QAAK,cAAL,CAAoB,EAApB,CAAuB,KAAvB,EAA8B,KAAK,cAAL,CAAoB,KAApB,CAA9B,EADmB;;;AAjDf,8BAwDL,6CAAkB;AACjB,iBAAO,GAAP,CAAW,KAAK,cAAL,EAAqB,KAAK,eAAL,CAAqB,IAArB,CAA0B,IAA1B,CAAhC,EADiB;AAEjB,QAAK,cAAL,GAAsB,IAAtB,CAFiB;AAGjB,QAAK,cAAL,GAAsB,IAAtB,CAHiB;AAIjB,QAAK,cAAL,GAAsB,IAAtB,CAJiB;;;AAxDb,8BAmEL,mCAAY,OAAO;AAClB,OAAI,CAAC,KAAK,iBAAL,CAAuB,KAAvB,CAAD,EAAgC;AACnC,WADmC;IAApC;;AAIA,OAAI,OAAO,IAAP,CALc;AAMlB,QAAK,cAAL,CAAoB,KAApB,IAA6B,YAAW;AACvC,QAAI,OAAO,CAAC,KAAD,EAAQ,MAAR,CAAe,MAAM,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,SAA3B,EAAsC,CAAtC,CAAf,CAAP,CADmC;AAEvC,SAAK,cAAL,CAAoB,IAApB,CAAyB,KAAzB,CAA+B,KAAK,cAAL,EAAqB,IAApD,EAFuC;IAAX,CANX;;AAWlB,QAAK,YAAL,CAAkB,KAAlB,EAXkB;;;AAnEd,8BAsFL,2CAAgB,OAAO;AACtB,QAAK,cAAL,CAAoB,cAApB,CAAmC,KAAnC,EAA0C,KAAK,cAAL,CAAoB,KAApB,CAA1C,EADsB;;;AAtFlB,8BAgGL,+CAAkB,OAAO;AACxB,OAAI,KAAK,UAAL,IAAmB,CAAC,KAAK,UAAL,CAAgB,KAAhB,CAAD,EAAyB;AAC/C,WAAO,KAAP,CAD+C;IAAhD;AAGA,OAAI,KAAK,UAAL,CAAgB,KAAhB,CAAJ,EAA4B;AAC3B,WAAO,KAAP,CAD2B;IAA5B;AAGA,UAAO,CAAC,KAAK,cAAL,CAAoB,KAApB,CAAD,CAPiB;;;AAhGpB,8BA8GL,qCAAc;AACb,QAAK,cAAL,CAAoB,EAApB,CAAuB,aAAvB,EAAsC,KAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAtB,CAAtC,EADa;;;SA9GT;;;;mBAmHS","sourcesContent":["'use strict';\n\nimport { Disposable, object } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist || {};\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = {};\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the proxy listener for the given event.\n\t * @param {string} event.\n\t * @protected\n\t */\n\taddListener_(event) {\n\t\tthis.originEmitter_.on(event, this.proxiedEvents_[event]);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tobject.map(this.proxiedEvents_, this.removeListener_.bind(this));\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent_(event) {\n\t\tif (!this.shouldProxyEvent_(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tthis.proxiedEvents_[event] = function() {\n\t\t\tvar args = [event].concat(Array.prototype.slice.call(arguments, 0));\n\t\t\tself.targetEmitter_.emit.apply(self.targetEmitter_, args);\n\t\t};\n\n\t\tthis.addListener_(event);\n\t}\n\n\t/**\n\t * Removes the proxy listener for the given event.\n\t * @param {string} event\n\t * @protected\n\t */\n\tremoveListener_(event) {\n\t\tthis.originEmitter_.removeListener(event, this.proxiedEvents_[event]);\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.on('newListener', this.proxyEvent_.bind(this));\n\t}\n}\n\nexport default EventEmitterProxy;\n"]}