package ${packagePath}.service.base;

import aQute.bnd.annotation.ProviderType;

import com.liferay.exportimport.kernel.lar.ExportImportHelperUtil;
import com.liferay.exportimport.kernel.lar.ManifestSummary;
import com.liferay.exportimport.kernel.lar.PortletDataContext;
import com.liferay.exportimport.kernel.lar.StagedModelDataHandler;
import com.liferay.exportimport.kernel.lar.StagedModelDataHandlerRegistryUtil;
import com.liferay.exportimport.kernel.lar.StagedModelDataHandlerUtil;
import com.liferay.exportimport.kernel.lar.StagedModelType;
import com.liferay.portal.kernel.bean.BeanReference;
import com.liferay.portal.kernel.bean.PortalBeanLocatorUtil;
import ${beanLocatorUtil};
import com.liferay.portal.kernel.dao.db.DB;
import com.liferay.portal.kernel.dao.db.DBManagerUtil;
import com.liferay.portal.kernel.dao.jdbc.SqlUpdate;
import com.liferay.portal.kernel.dao.jdbc.SqlUpdateFactoryUtil;
import com.liferay.portal.kernel.dao.orm.ActionableDynamicQuery;
import com.liferay.portal.kernel.dao.orm.Conjunction;
import com.liferay.portal.kernel.dao.orm.Criterion;
import com.liferay.portal.kernel.dao.orm.DefaultActionableDynamicQuery;
import com.liferay.portal.kernel.dao.orm.Disjunction;
import com.liferay.portal.kernel.dao.orm.DynamicQuery;
import com.liferay.portal.kernel.dao.orm.DynamicQueryFactoryUtil;
import com.liferay.portal.kernel.dao.orm.ExportActionableDynamicQuery;
import com.liferay.portal.kernel.dao.orm.IndexableActionableDynamicQuery;
import com.liferay.portal.kernel.dao.orm.Projection;
import com.liferay.portal.kernel.dao.orm.ProjectionFactoryUtil;
import com.liferay.portal.kernel.dao.orm.Property;
import com.liferay.portal.kernel.dao.orm.PropertyFactoryUtil;
import com.liferay.portal.kernel.dao.orm.RestrictionsFactoryUtil;
import com.liferay.portal.kernel.dao.orm.Session;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.model.PersistedModel;
import com.liferay.portal.kernel.module.framework.service.IdentifiableOSGiService;
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
import com.liferay.portal.kernel.search.Indexer;
import com.liferay.portal.kernel.search.IndexerRegistryUtil;
import com.liferay.portal.kernel.search.SearchException;
import com.liferay.portal.kernel.service.Base${sessionTypeName}ServiceImpl;
import com.liferay.portal.kernel.service.PersistedModelLocalServiceRegistry;
import com.liferay.portal.kernel.service.PersistedModelLocalServiceRegistryUtil;
import com.liferay.portal.kernel.util.InfrastructureUtil;
import com.liferay.portal.kernel.util.OrderByComparator;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.portal.kernel.workflow.WorkflowConstants;
import com.liferay.portal.spring.extender.service.ServiceReference;

import java.io.Serializable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;
import ${apiPackagePath}.service.${entity.name}${sessionTypeName}Service;

<#if entity.hasColumns()>
	<#if entity.hasCompoundPK()>
		import ${apiPackagePath}.service.persistence.${entity.name}PK;
	</#if>

	import ${apiPackagePath}.model.${entity.name};

	<#list entity.blobList as column>
		<#if column.lazy>
			import ${apiPackagePath}.model.${entity.name}${column.methodName}BlobModel;
		</#if>
	</#list>

	import ${packagePath}.model.impl.${entity.name}Impl;
</#if>

<#if entity.localizedEntity??>
	import ${apiPackagePath}.model.${entity.name}Localization;
</#if>

<#list referenceList as tempEntity>
	<#if tempEntity.hasColumns() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
		import ${tempEntity.apiPackagePath}.service.persistence.${tempEntity.name}Persistence;
		import ${tempEntity.apiPackagePath}.service.persistence.${tempEntity.name}Util;
	</#if>

	<#if tempEntity.hasFinderClass() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
		import ${tempEntity.apiPackagePath}.service.persistence.${tempEntity.name}Finder;
		import ${tempEntity.apiPackagePath}.service.persistence.${tempEntity.name}FinderUtil;
	</#if>
</#list>

<#if stringUtil.equals(sessionTypeName, "Local")>
/**
 * Provides the base implementation for the ${entity.humanName} local service.
 *
 * <p>
 * This implementation exists only as a container for the default service methods generated by ServiceBuilder. All custom service methods should be put in {@link ${packagePath}.service.impl.${entity.name}LocalServiceImpl}.
 * </p>
 *
 * @author ${author}
 * @see ${packagePath}.service.impl.${entity.name}LocalServiceImpl
 * @see ${apiPackagePath}.service.${entity.name}LocalServiceUtil
<#if classDeprecated>
 * @deprecated ${classDeprecatedComment}
</#if>
 * @generated
 */

<#if classDeprecated>
	@Deprecated
</#if>

	@ProviderType
	public abstract class ${entity.name}LocalServiceBaseImpl extends BaseLocalServiceImpl implements ${entity.name}LocalService, IdentifiableOSGiService {

		/*
		 * NOTE FOR DEVELOPERS:
		 *
		 * Never modify or reference this class directly. Always use {@link ${apiPackagePath}.service.${entity.name}LocalServiceUtil} to access the ${entity.humanName} local service.
		 */
<#else>
/**
 * Provides the base implementation for the ${entity.humanName} remote service.
 *
 * <p>
 * This implementation exists only as a container for the default service methods generated by ServiceBuilder. All custom service methods should be put in {@link ${packagePath}.service.impl.${entity.name}ServiceImpl}.
 * </p>
 *
 * @author ${author}
 * @see ${packagePath}.service.impl.${entity.name}ServiceImpl
 * @see ${apiPackagePath}.service.${entity.name}ServiceUtil
<#if classDeprecated>
 * @deprecated ${classDeprecatedComment}
</#if>
 * @generated
 */

<#if classDeprecated>
	@Deprecated
</#if>

	public abstract class ${entity.name}ServiceBaseImpl extends BaseServiceImpl implements ${entity.name}Service, IdentifiableOSGiService {

		/*
		 * NOTE FOR DEVELOPERS:
		 *
		 * Never modify or reference this class directly. Always use {@link ${apiPackagePath}.service.${entity.name}ServiceUtil} to access the ${entity.humanName} remote service.
		 */
</#if>

	<#if stringUtil.equals(sessionTypeName, "Local") && entity.hasColumns()>
		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "add" + entity.name, [apiPackagePath + ".model." + entity.name], []) />

		/**
		 * Adds the ${entity.humanName} to the database. Also notifies the appropriate model listeners.
		 *
		 * @param ${entity.varName} the ${entity.humanName}
		 * @return the ${entity.humanName} that was added
		<#list serviceBaseExceptions as exception>
		 * @throws ${exception}
		</#list>
		 */
		@Indexable(type = IndexableType.REINDEX)
		@Override
		public ${entity.name} add${entity.name}(${entity.name} ${entity.varName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			${entity.varName}.setNew(true);

			return ${entity.varName}Persistence.update(${entity.varName});
		}

		/**
		 * Creates a new ${entity.humanName} with the primary key. Does not add the ${entity.humanName} to the database.
		 *
		 * @param ${entity.PKVarName} the primary key for the new ${entity.humanName}
		 * @return the new ${entity.humanName}
		 */
		@Override
		public ${entity.name} create${entity.name}(${entity.PKClassName} ${entity.PKVarName}) {
			return ${entity.varName}Persistence.create(${entity.PKVarName});
		}

		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + entity.name, [entity.PKClassName], ["PortalException"]) />

		/**
		 * Deletes the ${entity.humanName} with the primary key from the database. Also notifies the appropriate model listeners.
		 *
		 * @param ${entity.PKVarName} the primary key of the ${entity.humanName}
		 * @return the ${entity.humanName} that was removed
		<#list serviceBaseExceptions as exception>
		<#if stringUtil.equals(exception, "PortalException")>
		 * @throws PortalException if a ${entity.humanName} with the primary key could not be found
		<#else>
		 * @throws ${exception}
		</#if>
		</#list>
		 */
		@Indexable(type = IndexableType.DELETE)
		@Override
		public ${entity.name} delete${entity.name}(${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			return ${entity.varName}Persistence.remove(${entity.PKVarName});
		}

		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + entity.name, [apiPackagePath + ".model." + entity.name], []) />

		/**
		 * Deletes the ${entity.humanName} from the database. Also notifies the appropriate model listeners.
		 *
		 * @param ${entity.varName} the ${entity.humanName}
		 * @return the ${entity.humanName} that was removed
		<#list serviceBaseExceptions as exception>
		 * @throws ${exception}
		</#list>
		 */
		@Indexable(type = IndexableType.DELETE)
		@Override
		public ${entity.name} delete${entity.name}(${entity.name} ${entity.varName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			return ${entity.varName}Persistence.remove(${entity.varName});
		}

		@Override
		public DynamicQuery dynamicQuery() {
			Class<?> clazz = getClass();

			return DynamicQueryFactoryUtil.forClass(${entity.name}.class, clazz.getClassLoader());
		}

		/**
		 * Performs a dynamic query on the database and returns the matching rows.
		 *
		 * @param dynamicQuery the dynamic query
		 * @return the matching rows
		 */
		@Override
		public <T> List<T> dynamicQuery(DynamicQuery dynamicQuery) {
			return ${entity.varName}Persistence.findWithDynamicQuery(dynamicQuery);
		}

		/**
		 * Performs a dynamic query on the database and returns a range of the matching rows.
		 *
		 * <p>
		 * <#include "range_comment.ftl">
		 * </p>
		 *
		 * @param dynamicQuery the dynamic query
		 * @param start the lower bound of the range of model instances
		 * @param end the upper bound of the range of model instances (not inclusive)
		 * @return the range of matching rows
		 */
		@Override
		public <T> List<T> dynamicQuery(DynamicQuery dynamicQuery, int start, int end) {
			return ${entity.varName}Persistence.findWithDynamicQuery(dynamicQuery, start, end);
		}

		/**
		 * Performs a dynamic query on the database and returns an ordered range of the matching rows.
		 *
		 * <p>
		 * <#include "range_comment.ftl">
		 * </p>
		 *
		 * @param dynamicQuery the dynamic query
		 * @param start the lower bound of the range of model instances
		 * @param end the upper bound of the range of model instances (not inclusive)
		 * @param orderByComparator the comparator to order the results by (optionally <code>null</code>)
		 * @return the ordered range of matching rows
		 */
		@Override
		public <T> List<T> dynamicQuery(DynamicQuery dynamicQuery, int start, int end, OrderByComparator<T> orderByComparator) {
			return ${entity.varName}Persistence.findWithDynamicQuery(dynamicQuery, start, end, orderByComparator);
		}

		/**
		 * Returns the number of rows matching the dynamic query.
		 *
		 * @param dynamicQuery the dynamic query
		 * @return the number of rows matching the dynamic query
		 */
		@Override
		public long dynamicQueryCount(DynamicQuery dynamicQuery) {
			return ${entity.varName}Persistence.countWithDynamicQuery(dynamicQuery);
		}

		/**
		 * Returns the number of rows matching the dynamic query.
		 *
		 * @param dynamicQuery the dynamic query
		 * @param projection the projection to apply to the query
		 * @return the number of rows matching the dynamic query
		 */
		@Override
		public long dynamicQueryCount(DynamicQuery dynamicQuery, Projection projection) {
			return ${entity.varName}Persistence.countWithDynamicQuery(dynamicQuery, projection);
		}

		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "fetch" + entity.name, [entity.PKClassName], []) />

		@Override
		public ${entity.name} fetch${entity.name}(${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			return ${entity.varName}Persistence.fetchByPrimaryKey(${entity.PKVarName});
		}

		<#if entity.hasUuid() && entity.hasColumn("companyId") && (!entity.hasColumn("groupId") || stringUtil.equals(entity.name, "Group"))>
			/**
			 * Returns the ${entity.humanName} with the matching UUID and company.
			 *
			 * @param uuid the ${entity.humanName}'s UUID
			 * @param companyId the primary key of the company
			 * @return the matching ${entity.humanName}, or <code>null</code> if a matching ${entity.humanName} could not be found
			<#list serviceBaseExceptions as exception>
			 * @throws ${exception}
			</#list>
			 */
			@Override
			public ${entity.name} fetch${entity.name}ByUuidAndCompanyId(String uuid, long companyId) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
				return ${entity.varName}Persistence.fetchByUuid_C_First(uuid, companyId, null);
			}
		</#if>

		<#if entity.hasUuid() && entity.hasColumn("groupId") && !stringUtil.equals(entity.name, "Group")>
			<#if stringUtil.equals(entity.name, "Layout")>
				/**
				 * Returns the ${entity.humanName} matching the UUID, group, and privacy.
				 *
				 * @param uuid the ${entity.humanName}'s UUID
				 * @param groupId the primary key of the group
				 * @param privateLayout whether the ${entity.humanName} is private to the group
				 * @return the matching ${entity.humanName}, or <code>null</code> if a matching ${entity.humanName} could not be found
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public ${entity.name} fetch${entity.name}ByUuidAndGroupId(String uuid, long groupId, boolean privateLayout) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${entity.varName}Persistence.fetchByUUID_G_P(uuid, groupId, privateLayout);
				}
			<#else>
				/**
				 * Returns the ${entity.humanName} matching the UUID and group.
				 *
				 * @param uuid the ${entity.humanName}'s UUID
				 * @param groupId the primary key of the group
				 * @return the matching ${entity.humanName}, or <code>null</code> if a matching ${entity.humanName} could not be found
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public ${entity.name} fetch${entity.name}ByUuidAndGroupId(String uuid, long groupId) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${entity.varName}Persistence.fetchByUUID_G(uuid, groupId);
				}
			</#if>
		</#if>

		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "get" + entity.name, [entity.PKClassName], ["PortalException"]) />

		/**
		 * Returns the ${entity.humanName} with the primary key.
		 *
		 * @param ${entity.PKVarName} the primary key of the ${entity.humanName}
		 * @return the ${entity.humanName}
		<#list serviceBaseExceptions as exception>
		<#if stringUtil.equals(exception, "PortalException")>
		 * @throws PortalException if a ${entity.humanName} with the primary key could not be found
		<#else>
		 * @throws ${exception}
		</#if>
		</#list>
		 */
		@Override
		public ${entity.name} get${entity.name}(${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			return ${entity.varName}Persistence.findByPrimaryKey(${entity.PKVarName});
		}

		<#if entity.hasActionableDynamicQuery()>
			@Override
			public ActionableDynamicQuery getActionableDynamicQuery() {
				ActionableDynamicQuery actionableDynamicQuery = new DefaultActionableDynamicQuery();

				actionableDynamicQuery.setBaseLocalService(${entity.varName}LocalService);
				actionableDynamicQuery.setClassLoader(getClassLoader());
				actionableDynamicQuery.setModelClass(${entity.name}.class);

				<#if entity.hasPrimitivePK()>
					actionableDynamicQuery.setPrimaryKeyPropertyName("${entity.PKVarName}");
				<#else>
					<#assign
						pkList = entity.getPKList()

						pkColumn = pkList?first
					/>

					actionableDynamicQuery.setPrimaryKeyPropertyName("primaryKey.${pkColumn.name}");

					<#list entity.getPKList() as pkColumn>
						<#if stringUtil.equals(pkColumn.name, "groupId")>
							actionableDynamicQuery.setGroupIdPropertyName("primaryKey.groupId");
						</#if>
					</#list>
				</#if>

				return actionableDynamicQuery;
			}

			@Override
			public IndexableActionableDynamicQuery getIndexableActionableDynamicQuery() {
				IndexableActionableDynamicQuery indexableActionableDynamicQuery = new IndexableActionableDynamicQuery();

				indexableActionableDynamicQuery.setBaseLocalService(${entity.varName}LocalService);
				indexableActionableDynamicQuery.setClassLoader(getClassLoader());
				indexableActionableDynamicQuery.setModelClass(${entity.name}.class);

				<#if entity.hasPrimitivePK()>
					indexableActionableDynamicQuery.setPrimaryKeyPropertyName("${entity.PKVarName}");
				<#else>
					<#assign
						pkList = entity.getPKList()

						pkColumn = pkList?first
					/>

					indexableActionableDynamicQuery.setPrimaryKeyPropertyName("primaryKey.${pkColumn.name}");

					<#list entity.getPKList() as pkColumn>
						<#if stringUtil.equals(pkColumn.name, "groupId")>
							indexableActionableDynamicQuery.setGroupIdPropertyName("primaryKey.groupId");
						</#if>
					</#list>
				</#if>

				return indexableActionableDynamicQuery;
			}

			protected void initActionableDynamicQuery(ActionableDynamicQuery actionableDynamicQuery) {
				actionableDynamicQuery.setBaseLocalService(${entity.varName}LocalService);
				actionableDynamicQuery.setClassLoader(getClassLoader());
				actionableDynamicQuery.setModelClass(${entity.name}.class);

				<#if entity.hasPrimitivePK()>
					actionableDynamicQuery.setPrimaryKeyPropertyName("${entity.PKVarName}");
				<#else>
					<#assign
						pkList = entity.getPKList()

						pkColumn = pkList?first
					/>

					actionableDynamicQuery.setPrimaryKeyPropertyName("primaryKey.${pkColumn.name}");

					<#list entity.getPKList() as pkColumn>
						<#if stringUtil.equals(pkColumn.name, "groupId")>
							actionableDynamicQuery.setGroupIdPropertyName("primaryKey.groupId");
						</#if>
					</#list>
				</#if>
			}

			<#if entity.isStagedModel()>
				@Override
				public ExportActionableDynamicQuery getExportActionableDynamicQuery(final PortletDataContext portletDataContext) {
					final ExportActionableDynamicQuery exportActionableDynamicQuery = new ExportActionableDynamicQuery() {

						@Override
						public long performCount() throws PortalException {
							ManifestSummary manifestSummary = portletDataContext.getManifestSummary();

							StagedModelType stagedModelType = getStagedModelType();

							long modelAdditionCount = super.performCount();

							manifestSummary.addModelAdditionCount(stagedModelType, modelAdditionCount);

							long modelDeletionCount = ExportImportHelperUtil.getModelDeletionCount(portletDataContext, stagedModelType);

							manifestSummary.addModelDeletionCount(stagedModelType, modelDeletionCount);

							return modelAdditionCount;
						}

						<#if entity.isResourcedModel()>
							@Override
							protected Projection getCountProjection() {
								return ProjectionFactoryUtil.countDistinct("resourcePrimKey");
							}
						</#if>
					};

					initActionableDynamicQuery(exportActionableDynamicQuery);

					exportActionableDynamicQuery.setAddCriteriaMethod(
						new ActionableDynamicQuery.AddCriteriaMethod() {

							@Override
							public void addCriteria(DynamicQuery dynamicQuery) {
								<#if entity.isWorkflowEnabled()>
									Criterion modifiedDateCriterion = portletDataContext.getDateRangeCriteria("modifiedDate");

									<#if entity.isStagedGroupedModel()>
										if (modifiedDateCriterion != null) {
											Conjunction conjunction = RestrictionsFactoryUtil.conjunction();

											conjunction.add(modifiedDateCriterion);

											Disjunction disjunction = RestrictionsFactoryUtil.disjunction();

											disjunction.add(RestrictionsFactoryUtil.gtProperty("modifiedDate", "lastPublishDate"));

											Property lastPublishDateProperty = PropertyFactoryUtil.forName("lastPublishDate");

											disjunction.add(lastPublishDateProperty.isNull());

											conjunction.add(disjunction);

											modifiedDateCriterion = conjunction;
										}
									</#if>

									Criterion statusDateCriterion = portletDataContext.getDateRangeCriteria("statusDate");

									if ((modifiedDateCriterion != null) && (statusDateCriterion != null)) {
										Disjunction disjunction = RestrictionsFactoryUtil.disjunction();

										disjunction.add(modifiedDateCriterion);
										disjunction.add(statusDateCriterion);

										dynamicQuery.add(disjunction);
									}
								<#else>
									portletDataContext.addDateRangeCriteria(dynamicQuery, "modifiedDate");
								</#if>

								<#if entity.isTypedModel()>
									StagedModelType stagedModelType = exportActionableDynamicQuery.getStagedModelType();

									long referrerClassNameId = stagedModelType.getReferrerClassNameId();

									Property classNameIdProperty = PropertyFactoryUtil.forName("classNameId");

									if ((referrerClassNameId != StagedModelType.REFERRER_CLASS_NAME_ID_ALL) && (referrerClassNameId != StagedModelType.REFERRER_CLASS_NAME_ID_ANY)) {
										dynamicQuery.add(classNameIdProperty.eq(stagedModelType.getReferrerClassNameId()));
									}
									else if (referrerClassNameId == StagedModelType.REFERRER_CLASS_NAME_ID_ANY) {
										dynamicQuery.add(classNameIdProperty.isNotNull());
									}
								</#if>

								<#if entity.isWorkflowEnabled()>
									Property workflowStatusProperty = PropertyFactoryUtil.forName("status");

									if (portletDataContext.isInitialPublication()) {
										dynamicQuery.add(workflowStatusProperty.ne(WorkflowConstants.STATUS_IN_TRASH));
									}
									else {
										StagedModelDataHandler<?> stagedModelDataHandler = StagedModelDataHandlerRegistryUtil.getStagedModelDataHandler(${entity.name}.class.getName());

										dynamicQuery.add(workflowStatusProperty.in(stagedModelDataHandler.getExportableStatuses()));
									}
								</#if>
							}

						});

					exportActionableDynamicQuery.setCompanyId(portletDataContext.getCompanyId());

					<#if entity.isStagedGroupedModel()>
						exportActionableDynamicQuery.setGroupId(portletDataContext.getScopeGroupId());
					</#if>

					exportActionableDynamicQuery.setPerformActionMethod(
						new ActionableDynamicQuery.PerformActionMethod<${entity.name}>() {

							@Override
							public void performAction(${entity.name} ${entity.varName}) throws PortalException {
								StagedModelDataHandlerUtil.exportStagedModel(portletDataContext, ${entity.varName});
							}

						});
					<#if entity.isTypedModel()>
						exportActionableDynamicQuery.setStagedModelType(new StagedModelType(PortalUtil.getClassNameId(${entity.name}.class.getName()), StagedModelType.REFERRER_CLASS_NAME_ID_ALL));
					<#else>
						exportActionableDynamicQuery.setStagedModelType(new StagedModelType(PortalUtil.getClassNameId(${entity.name}.class.getName())));
					</#if>

					return exportActionableDynamicQuery;
				}
			</#if>
		</#if>

		/**
		 * @throws PortalException
		 */
		@Override
		public PersistedModel deletePersistedModel(PersistedModel persistedModel) throws PortalException {
			return ${entity.varName}LocalService.delete${entity.name}((${entity.name})persistedModel);
		}

		@Override
		public PersistedModel getPersistedModel(Serializable primaryKeyObj) throws PortalException {
			return ${entity.varName}Persistence.findByPrimaryKey(primaryKeyObj);
		}

		<#if entity.hasUuid() && entity.hasColumn("companyId")>
			<#if entity.hasColumn("groupId") && !stringUtil.equals(entity.name, "Group")>
				/**
				 * Returns all the ${entity.humanNames} matching the UUID and company.
				 *
				 * @param uuid the UUID of the ${entity.humanNames}
				 * @param companyId the primary key of the company
				 * @return the matching ${entity.humanNames}, or an empty list if no matches were found
				 */
				@Override
				public List<${entity.name}> get${entity.names}ByUuidAndCompanyId(String uuid, long companyId) {
					return ${entity.varName}Persistence.findByUuid_C(uuid, companyId);
				}

				/**
				 * Returns a range of ${entity.humanNames} matching the UUID and company.
				 *
				 * @param uuid the UUID of the ${entity.humanNames}
				 * @param companyId the primary key of the company
				 * @param start the lower bound of the range of ${entity.humanNames}
				 * @param end the upper bound of the range of ${entity.humanNames} (not inclusive)
				 * @param orderByComparator the comparator to order the results by (optionally <code>null</code>)
				 * @return the range of matching ${entity.humanNames}, or an empty list if no matches were found
				 */
				@Override
				public List<${entity.name}> get${entity.names}ByUuidAndCompanyId(String uuid, long companyId, int start, int end, OrderByComparator<${entity.name}> orderByComparator) {
					return ${entity.varName}Persistence.findByUuid_C(uuid, companyId, start, end, orderByComparator);
				}
			<#else>
				/**
				 * Returns the ${entity.humanName} with the matching UUID and company.
				 *
				 * @param uuid the ${entity.humanName}'s UUID
				 * @param companyId the primary key of the company
				 * @return the matching ${entity.humanName}
				<#list serviceBaseExceptions as exception>
				<#if stringUtil.equals(exception, "PortalException")>
				 * @throws PortalException if a matching ${entity.humanName} could not be found
				<#else>
				 * @throws ${exception}
				</#if>
				</#list>
				 */
				@Override
				public ${entity.name} get${entity.name}ByUuidAndCompanyId(String uuid, long companyId) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${entity.varName}Persistence.findByUuid_C_First(uuid, companyId, null);
				}
			</#if>
		</#if>

		<#if entity.hasUuid() && entity.hasColumn("groupId") && !stringUtil.equals(entity.name, "Group")>
			<#if stringUtil.equals(entity.name, "Layout")>
				/**
				 * Returns the ${entity.humanName} matching the UUID, group, and privacy.
				 *
				 * @param uuid the ${entity.humanName}'s UUID
				 * @param groupId the primary key of the group
				 * @param privateLayout whether the ${entity.humanName} is private to the group
				 * @return the matching ${entity.humanName}
				<#list serviceBaseExceptions as exception>
				<#if stringUtil.equals(exception, "PortalException")>
				 * @throws PortalException if a matching ${entity.humanName} could not be found
				<#else>
				 * @throws ${exception}
				</#if>
				</#list>
				 */
				@Override
				public ${entity.name} get${entity.name}ByUuidAndGroupId(String uuid, long groupId, boolean privateLayout) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${entity.varName}Persistence.findByUUID_G_P(uuid, groupId, privateLayout);
				}
			<#else>
				/**
				 * Returns the ${entity.humanName} matching the UUID and group.
				 *
				 * @param uuid the ${entity.humanName}'s UUID
				 * @param groupId the primary key of the group
				 * @return the matching ${entity.humanName}
				<#list serviceBaseExceptions as exception>
				<#if stringUtil.equals(exception, "PortalException")>
				 * @throws PortalException if a matching ${entity.humanName} could not be found
				<#else>
				 * @throws ${exception}
				</#if>
				</#list>
				 */
				@Override
				public ${entity.name} get${entity.name}ByUuidAndGroupId(String uuid, long groupId) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${entity.varName}Persistence.findByUUID_G(uuid, groupId);
				}
			</#if>
		</#if>

		/**
		 * Returns a range of all the ${entity.humanNames}.
		 *
		 * <p>
		 * <#include "range_comment.ftl">
		 * </p>
		 *
		 * @param start the lower bound of the range of ${entity.humanNames}
		 * @param end the upper bound of the range of ${entity.humanNames} (not inclusive)
		 * @return the range of ${entity.humanNames}
		 */
		@Override
		public List<${entity.name}> get${entity.names}(int start, int end) {
			return ${entity.varName}Persistence.findAll(start, end);
		}

		/**
		 * Returns the number of ${entity.humanNames}.
		 *
		 * @return the number of ${entity.humanNames}
		 */
		@Override
		public int get${entity.names}Count() {
			return ${entity.varName}Persistence.countAll();
		}

		<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "update" + entity.name, [apiPackagePath + ".model." + entity.name], []) />

		/**
		 * Updates the ${entity.humanName} in the database or adds it if it does not yet exist. Also notifies the appropriate model listeners.
		 *
		 * @param ${entity.varName} the ${entity.humanName}
		 * @return the ${entity.humanName} that was updated
		<#list serviceBaseExceptions as exception>
		 * @throws ${exception}
		</#list>
		 */
		@Indexable(type = IndexableType.REINDEX)
		@Override
		public ${entity.name} update${entity.name}(${entity.name} ${entity.varName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
			return ${entity.varName}Persistence.update(${entity.varName});
		}

		<#list entity.blobList as column>
			<#if column.lazy>
				@Override
				public ${entity.name}${column.methodName}BlobModel get${column.methodName}BlobModel(Serializable primaryKey) {
					Session session = null;

					try {
						session = ${entity.varName}Persistence.openSession();

						return (${apiPackagePath}.model.${entity.name}${column.methodName}BlobModel)session.get(${entity.name}${column.methodName}BlobModel.class, primaryKey);
					}
					catch (Exception e) {
						throw ${entity.varName}Persistence.processException(e);
					}
					finally {
						${entity.varName}Persistence.closeSession(session);
					}
				}
			</#if>
		</#list>

		<#list entity.columnList as column>
			<#if column.isCollection() && column.isMappingManyToMany()>
				<#assign
					tempEntity = serviceBuilder.getEntity(column.getEJBName())

					serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "add" + tempEntity.name + entity.name, [tempEntity.PKClassName, entity.PKClassName], [])
				/>

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void add${tempEntity.name}${entity.name}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.add${entity.name}(${tempEntity.PKVarName}, ${entity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "add" + tempEntity.name + entity.name, [tempEntity.PKClassName, apiPackagePath + ".model." + entity.name], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void add${tempEntity.name}${entity.name}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.name} ${entity.varName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.add${entity.name}(${tempEntity.PKVarName}, ${entity.varName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "add" + tempEntity.name + entity.names, [tempEntity.PKClassName, entity.PKClassName + "[]"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void add${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName}[] ${entity.PKVarNames}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.add${entity.names}(${tempEntity.PKVarName}, ${entity.PKVarNames});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "add" + tempEntity.name + entity.names, [tempEntity.PKClassName, "java.util.List<" + entity.name + ">"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void add${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, List<${entity.name}> ${entity.varNames}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.add${entity.names}(${tempEntity.PKVarName}, ${entity.varNames});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "clear" + tempEntity.name + entity.names, [tempEntity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void clear${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.clear${entity.names}(${tempEntity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + tempEntity.name + entity.name, [tempEntity.PKClassName, entity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void delete${tempEntity.name}${entity.name}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.remove${entity.name}(${tempEntity.PKVarName}, ${entity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + tempEntity.name + entity.name, [tempEntity.PKClassName, apiPackagePath + ".model." + entity.name], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void delete${tempEntity.name}${entity.name}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.name} ${entity.varName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.remove${entity.name}(${tempEntity.PKVarName}, ${entity.varName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + tempEntity.name + entity.names, [tempEntity.PKClassName, entity.PKClassName + "[]"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void delete${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName}[] ${entity.PKVarNames}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.remove${entity.names}(${tempEntity.PKVarName}, ${entity.PKVarNames});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "delete" + tempEntity.name + entity.names, [tempEntity.PKClassName, "java.util.List<" + entity.name + ">"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void delete${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, List<${entity.name}> ${entity.varNames}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.remove${entity.names}(${tempEntity.PKVarName}, ${entity.varNames});
				}

				/**
				 * Returns the ${tempEntity.PKVarName}s of the ${tempEntity.humanNames} associated with the ${entity.humanName}.
				 *
				 * @param ${entity.PKVarName} the ${entity.PKVarName} of the ${entity.humanName}
				 * @return long[] the ${tempEntity.PKVarName}s of ${tempEntity.humanNames} associated with the ${entity.humanName}
				 */
				@Override
				public long[] get${tempEntity.name}PrimaryKeys(${entity.PKClassName} ${entity.PKVarName}) {
					return ${entity.varName}Persistence.get${tempEntity.name}PrimaryKeys(${entity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "get" + tempEntity.name + entity.names, [tempEntity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public List<${entity.name}> get${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.get${entity.names}(${tempEntity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "get" + tempEntity.name + entity.names, [tempEntity.PKClassName, "int", "int"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public List<${entity.name}> get${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, int start, int end) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.get${entity.names}(${tempEntity.PKVarName}, start, end);
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "get" + tempEntity.name + entity.names, [tempEntity.PKClassName, "int", "int", "com.liferay.portal.kernel.util.OrderByComparator"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public List<${entity.name}> get${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, int start, int end, OrderByComparator<${entity.name}> orderByComparator) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.get${entity.names}(${tempEntity.PKVarName}, start, end, orderByComparator);
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "get" + tempEntity.name + entity.names + "Count", [tempEntity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public int get${tempEntity.name}${entity.names}Count(${tempEntity.PKClassName} ${tempEntity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.get${entity.names}Size(${tempEntity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "has" + tempEntity.name + entity.name, [tempEntity.PKClassName, entity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public boolean has${tempEntity.name}${entity.name}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName} ${entity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.contains${entity.name}(${tempEntity.PKVarName}, ${entity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "has" + tempEntity.name + entity.names, [tempEntity.PKClassName], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public boolean has${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					return ${tempEntity.varName}Persistence.contains${entity.names}(${tempEntity.PKVarName});
				}

				<#assign serviceBaseExceptions = serviceBuilder.getServiceBaseExceptions(methods, "set" + tempEntity.name + entity.names, [tempEntity.PKClassName, entity.PKClassName + "[]"], []) />

				/**
				<#list serviceBaseExceptions as exception>
				 * @throws ${exception}
				</#list>
				 */
				@Override
				public void set${tempEntity.name}${entity.names}(${tempEntity.PKClassName} ${tempEntity.PKVarName}, ${entity.PKClassName}[] ${entity.PKVarNames}) <#if (serviceBaseExceptions?size gt 0)>throws ${stringUtil.merge(serviceBaseExceptions)} </#if>{
					${tempEntity.varName}Persistence.set${entity.names}(${tempEntity.PKVarName}, ${entity.PKVarNames});
				}
			</#if>
		</#list>
	</#if>

	<#if stringUtil.equals(sessionTypeName, "Local") && (entity.localizedEntity??)>
		<#assign
			localizedEntity = entity.localizedEntity
			localizedColumns = entity.localizedColumns
			pkColumn = entity.getPKList()?first
		/>

		@Override
		public ${localizedEntity.name} fetch${localizedEntity.name}(${entity.PKClassName} ${entity.PKVarName}, String languageId) {
			return ${localizedEntity.varName}Persistence.fetchBy${pkColumn.methodName}_LanguageId(${entity.PKVarName}, languageId);
		}

		@Override
		public ${localizedEntity.name} get${localizedEntity.name}(${entity.PKClassName} ${entity.PKVarName}, String languageId) throws PortalException {
			return ${localizedEntity.varName}Persistence.findBy${pkColumn.methodName}_LanguageId(${entity.PKVarName}, languageId);
		}

		@Override
		public List<${localizedEntity.name}> get${localizedEntity.names}(${entity.PKClassName} ${entity.PKVarName}) {
			return ${localizedEntity.varName}Persistence.findBy${pkColumn.methodName}(${entity.PKVarName});
		}

		protected ${localizedEntity.name} update${localizedEntity.name}(
			${entity.name} ${entity.varName}, String languageId,
			<#list localizedColumns as column>
				String ${column.name}

				<#if column?has_next>
					,
				</#if>
			</#list>
			) throws PortalException {

			${localizedEntity.name} ${localizedEntity.varName} = ${localizedEntity.varName}Persistence.fetchBy${pkColumn.methodName}_LanguageId(${entity.varName}.get${pkColumn.methodName}(), languageId);

			if (${localizedEntity.varName} == null) {
				long ${localizedEntity.varName}Id = counterLocalService.increment();

				${localizedEntity.varName} = ${localizedEntity.varName}Persistence.create(${localizedEntity.varName}Id);

				${localizedEntity.varName}.set${pkColumn.methodName}(${entity.varName}.get${pkColumn.methodName}());
				${localizedEntity.varName}.setLanguageId(languageId);
			}

			<#list entity.columnList as entityColumn>
				<#if localizedEntity.hasColumn(entityColumn.name) && !stringUtil.equals(entityColumn.name, "mvccVersion") && !stringUtil.equals(entityColumn.name, pkColumn.name)>
					${localizedEntity.varName}.set${entityColumn.methodName}(${entity.varName}.get${entityColumn.methodName}());
				</#if>
			</#list>

			<#list localizedColumns as column>
				${localizedEntity.varName}.set${column.methodName}(${column.name});
			</#list>

			return ${localizedEntity.varName}Persistence.update(${localizedEntity.varName});
		}

		protected List<${localizedEntity.name}> update${localizedEntity.names}(
			${entity.name} ${entity.varName},
			<#list localizedColumns as column>
				Map<String, String> ${column.name}Map

				<#if column?has_next>
					,
				</#if>
			</#list>
			) throws PortalException {

			Map<String, String[]> localizedValuesMap = new HashMap<String, String[]>();

			<#list localizedColumns as column>
				for (Map.Entry<String, String> entry : ${column.name}Map.entrySet()) {
					String languageId = entry.getKey();

					String[] localizedValues = localizedValuesMap.get(languageId);

					if (localizedValues == null) {
						localizedValues = new String[${localizedColumns?size}];

						localizedValuesMap.put(languageId, localizedValues);
					}

					localizedValues[${column?index}] = entry.getValue();
				}
			</#list>

			List<${localizedEntity.name}> ${localizedEntity.varNames} = new ArrayList<${localizedEntity.name}>(localizedValuesMap.size());

			for (${localizedEntity.name} ${localizedEntity.varName} : ${localizedEntity.varName}Persistence.findBy${pkColumn.methodName}(${entity.varName}.get${pkColumn.methodName}())) {
				String[] localizedValues = localizedValuesMap.remove(${localizedEntity.varName}.getLanguageId());

				if (localizedValues == null) {
					${localizedEntity.varName}Persistence.remove(${localizedEntity.varName});
				}
				else {
					<#list entity.columnList as entityColumn>
						<#if localizedEntity.hasColumn(entityColumn.name) && !stringUtil.equals(entityColumn.name, "mvccVersion") && !stringUtil.equals(entityColumn.name, pkColumn.name)>
							${localizedEntity.varName}.set${entityColumn.methodName}(${entity.varName}.get${entityColumn.methodName}());
						</#if>
					</#list>

					<#list localizedColumns as column>
						${localizedEntity.varName}.set${column.methodName}(localizedValues[${column?index}]);
					</#list>

					${localizedEntity.varNames}.add(${localizedEntity.varName}Persistence.update(${localizedEntity.varName}));
				}
			}

			for (Map.Entry<String, String[]> entry : localizedValuesMap.entrySet()) {
				String languageId = entry.getKey();
				String[] localizedValues = entry.getValue();

				long ${localizedEntity.PKVarName} = counterLocalService.increment();

				${localizedEntity.name} ${localizedEntity.varName} = ${localizedEntity.varName}Persistence.create(${localizedEntity.PKVarName});

				<#list entity.columnList as entityColumn>
					<#if localizedEntity.hasColumn(entityColumn.name) && !stringUtil.equals(entityColumn.name, "mvccVersion")>
						${localizedEntity.varName}.set${entityColumn.methodName}(${entity.varName}.get${entityColumn.methodName}());
					</#if>
				</#list>

				${localizedEntity.varName}.setLanguageId(languageId);

				<#list localizedColumns as column>
					${localizedEntity.varName}.set${column.methodName}(localizedValues[${column?index}]);
				</#list>

				${localizedEntity.varNames}.add(${localizedEntity.varName}Persistence.update(${localizedEntity.varName}));
			}

			return ${localizedEntity.varNames};
		}
	</#if>

	<#list referenceList as tempEntity>
		<#if tempEntity.hasLocalService()>
			/**
			 * Returns the ${tempEntity.humanName} local service.
			 *
			 * @return the ${tempEntity.humanName} local service
			 */

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			public ${tempEntity.apiPackagePath}.service.${tempEntity.name}LocalService get${tempEntity.name}LocalService() {
				return ${tempEntity.varName}LocalService;
			}

			/**
			 * Sets the ${tempEntity.humanName} local service.
			 *
			 * @param ${tempEntity.varName}LocalService the ${tempEntity.humanName} local service
			 */

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			public void set${tempEntity.name}LocalService(${tempEntity.apiPackagePath}.service.${tempEntity.name}LocalService ${tempEntity.varName}LocalService) {
				this.${tempEntity.varName}LocalService = ${tempEntity.varName}LocalService;
			}
		</#if>

		<#if !stringUtil.equals(sessionTypeName, "Local") && tempEntity.hasRemoteService()>
			/**
			 * Returns the ${tempEntity.humanName} remote service.
			 *
			 * @return the ${tempEntity.humanName} remote service
			 */

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			public ${tempEntity.apiPackagePath}.service.${tempEntity.name}Service get${tempEntity.name}Service() {
				return ${tempEntity.varName}Service;
			}

			/**
			 * Sets the ${tempEntity.humanName} remote service.
			 *
			 * @param ${tempEntity.varName}Service the ${tempEntity.humanName} remote service
			 */

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			public void set${tempEntity.name}Service(${tempEntity.apiPackagePath}.service.${tempEntity.name}Service ${tempEntity.varName}Service) {
				this.${tempEntity.varName}Service = ${tempEntity.varName}Service;
			}
		</#if>

		<#if tempEntity.hasColumns() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
			/**
			 * Returns the ${tempEntity.humanName} persistence.
			 *
			 * @return the ${tempEntity.humanName} persistence
			 */
			public ${tempEntity.name}Persistence get${tempEntity.name}Persistence() {
				return ${tempEntity.varName}Persistence;
			}

			/**
			 * Sets the ${tempEntity.humanName} persistence.
			 *
			 * @param ${tempEntity.varName}Persistence the ${tempEntity.humanName} persistence
			 */
			public void set${tempEntity.name}Persistence(${tempEntity.name}Persistence ${tempEntity.varName}Persistence) {
				this.${tempEntity.varName}Persistence = ${tempEntity.varName}Persistence;
			}
		</#if>

		<#if tempEntity.hasFinderClass() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
			/**
			 * Returns the ${tempEntity.humanName} finder.
			 *
			 * @return the ${tempEntity.humanName} finder
			 */
			public ${tempEntity.name}Finder get${tempEntity.name}Finder() {
				return ${tempEntity.varName}Finder;
			}

			/**
			 * Sets the ${tempEntity.humanName} finder.
			 *
			 * @param ${tempEntity.varName}Finder the ${tempEntity.humanName} finder
			 */
			public void set${tempEntity.name}Finder(${tempEntity.name}Finder ${tempEntity.varName}Finder) {
				this.${tempEntity.varName}Finder = ${tempEntity.varName}Finder;
			}
		</#if>
	</#list>

	public void afterPropertiesSet() {
		<#if validator.isNotNull(pluginName)>
			Class<?> clazz = getClass();

			_classLoader = clazz.getClassLoader();
		</#if>

		<#if stringUtil.equals(sessionTypeName, "Local") && entity.hasColumns()>
			<#if validator.isNotNull(pluginName)>
				PersistedModelLocalServiceRegistryUtil.register("${apiPackagePath}.model.${entity.name}", ${entity.varName}LocalService);
			<#else>
				persistedModelLocalServiceRegistry.register("${apiPackagePath}.model.${entity.name}", ${entity.varName}LocalService);
			</#if>
		</#if>
	}

	public void destroy() {
		<#if stringUtil.equals(sessionTypeName, "Local") && entity.hasColumns()>
			<#if validator.isNotNull(pluginName)>
				PersistedModelLocalServiceRegistryUtil.unregister("${apiPackagePath}.model.${entity.name}");
			<#else>
				persistedModelLocalServiceRegistry.unregister("${apiPackagePath}.model.${entity.name}");
			</#if>
		</#if>
	}

	/**
	 * Returns the OSGi service identifier.
	 *
	 * @return the OSGi service identifier
	 */
	@Override
	public String getOSGiServiceIdentifier() {
		<#if stringUtil.equals(sessionTypeName, "Local")>
			return ${entity.name}LocalService.class.getName();
		<#else>
			return ${entity.name}Service.class.getName();
		</#if>
	}

	<#if validator.isNotNull(pluginName)>
		@Override
		public Object invokeMethod(
				String name, String[] parameterTypes, Object[] arguments)
			throws Throwable {

			Thread currentThread = Thread.currentThread();

			ClassLoader contextClassLoader = currentThread.getContextClassLoader();

			if (contextClassLoader != _classLoader) {
				currentThread.setContextClassLoader(_classLoader);
			}

			try {
				return _clpInvoker.invokeMethod(name, parameterTypes, arguments);
			}
			finally {
				if (contextClassLoader != _classLoader) {
					currentThread.setContextClassLoader(contextClassLoader);
				}
			}
		}
	</#if>

	<#if entity.hasColumns()>
		protected Class<?> getModelClass() {
			return ${entity.name}.class;
		}

		protected String getModelClassName() {
			return ${entity.name}.class.getName();
		}
	</#if>

	/**
	 * Performs a SQL query.
	 *
	 * @param sql the sql query
	 */
	protected void runSQL(String sql) {
		try {
			<#if entity.hasColumns()>
				DataSource dataSource = ${entity.varName}Persistence.getDataSource();
			<#else>
				DataSource dataSource = InfrastructureUtil.getDataSource();
			</#if>

			DB db = DBManagerUtil.getDB();

			sql = db.buildSQL(sql);
			sql = PortalUtil.transformSQL(sql);

			SqlUpdate sqlUpdate = SqlUpdateFactoryUtil.getSqlUpdate(dataSource, sql);

			sqlUpdate.update();
		}
		catch (Exception e) {
			throw new SystemException(e);
		}
	}

	<#list referenceList as tempEntity>
		<#if tempEntity.hasLocalService()>
			<#if osgiModule && (tempEntity.apiPackagePath != apiPackagePath)>
				@ServiceReference(type = ${tempEntity.apiPackagePath}.service.${tempEntity.name}LocalService.class)
			<#else>
				@BeanReference(type = ${tempEntity.apiPackagePath}.service.${tempEntity.name}LocalService.class)
			</#if>

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			protected ${tempEntity.apiPackagePath}.service.${tempEntity.name}LocalService ${tempEntity.varName}LocalService;
		</#if>

		<#if !stringUtil.equals(sessionTypeName, "Local") && tempEntity.hasRemoteService()>
			<#if osgiModule && (tempEntity.apiPackagePath != apiPackagePath)>
				@ServiceReference(type = ${tempEntity.apiPackagePath}.service.${tempEntity.name}Service.class)
			<#else>
				@BeanReference(type = ${tempEntity.apiPackagePath}.service.${tempEntity.name}Service.class)
			</#if>

			<#if !classDeprecated && tempEntity.isDeprecated()>
				@SuppressWarnings("deprecation")
			</#if>

			protected ${tempEntity.apiPackagePath}.service.${tempEntity.name}Service ${tempEntity.varName}Service;
		</#if>

		<#if tempEntity.hasColumns() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
			<#if osgiModule && (tempEntity.apiPackagePath != apiPackagePath)>
				@ServiceReference(type = ${tempEntity.name}Persistence.class)
			<#else>
				@BeanReference(type = ${tempEntity.name}Persistence.class)
			</#if>

			protected ${tempEntity.name}Persistence ${tempEntity.varName}Persistence;
		</#if>

		<#if tempEntity.hasFinderClass() && (stringUtil.equals(entity.name, "Counter") || !stringUtil.equals(tempEntity.name, "Counter"))>
			<#if osgiModule && (tempEntity.apiPackagePath != apiPackagePath)>
				@ServiceReference(type = ${tempEntity.name}Finder.class)
			<#else>
				@BeanReference(type = ${tempEntity.name}Finder.class)
			</#if>

			protected ${tempEntity.name}Finder ${tempEntity.varName}Finder;
		</#if>
	</#list>

	<#if stringUtil.equals(sessionTypeName, "Local") && entity.hasColumns()>
		<#if validator.isNull(pluginName)>
			<#if osgiModule>
				@ServiceReference(type = PersistedModelLocalServiceRegistry.class)
			<#else>
				@BeanReference(type = PersistedModelLocalServiceRegistry.class)
			</#if>

			protected PersistedModelLocalServiceRegistry persistedModelLocalServiceRegistry;
		</#if>
	</#if>

	<#if validator.isNotNull(pluginName)>
		private ClassLoader _classLoader;
		private ${entity.name}${sessionTypeName}ServiceClpInvoker _clpInvoker = new ${entity.name}${sessionTypeName}ServiceClpInvoker();
	</#if>

}